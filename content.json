[{"title":"前端js经常忽略的问题","date":"2017-04-06T06:39:34.000Z","path":"posts/uncategorized/2017-04-06-js中一些常见的面试问题.html","text":"这道题综合考察了面试者的JavaScript的综合能力，包含了变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等知识 前端js经常忽略的问题1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125; //请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 这道题综合考察了面试者的JavaScript的综合能力，包含了变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等知识 题目分析先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。 第一问第一问的Foo.getName自然是访问Foo函数上存储的静态属性，答案自然是2，这里就不需要解释太多的，一般来说第一问对于稍微懂JS基础的同学来说应该是没问题的,当然我们可以用下面的代码来回顾一下基础，先加深一下了解 123456789101112131415function User(name) &#123; var name = name; //私有属性 this.name = name; //公有属性 function getName() &#123; //私有方法 return name; &#125;&#125;User.prototype.getName = function() &#123; //公有方法 return this.name;&#125;User.name = 'Wscats'; //静态属性User.getName = function() &#123; //静态方法 return this.name;&#125;var Wscat = new User('Wscats'); //实例化 ==注意一下几点== 调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的 静态方法和静态属性就是我们无需实例化就可以调用 而对象的私有方法和属性,外部是不可以访问的 第二问直接调用getName函数。既然是直接调用那么就是访问当前上文作用域内的叫getName的函数，所以这里应该直接把关注点放在4和5上，跟1 2 3都没什么关系。当然后来我问了我的几个同事他们大多数回答了5。此处其实有两个坑，一是变量声明提升，二是函数表达式和函数声明的区别。我们来看看为什么，可参考(1)关于Javascript的函数声明和函数表达式 (2)关于JavaScript的变量提升在Javascript中，定义函数有两种类型 函数声明1234// 函数声明function wscat(type)&#123; return type===\"wscat\";&#125; 函数表达式1234// 函数表达式var oaoafly = function(type)&#123; return type===\"oaoafly\";&#125; 先看下面这个经典问题，在一个程序里面同时用函数声明和函数表达式定义一个名为getName的函数123456789getName()//oaoaflyvar getName = function() &#123; console.log('wscat')&#125;getName()//wscatfunction getName() &#123; console.log('oaoafly')&#125;getName()//wscat 上面的代码看起来很类似，感觉也没什么太大差别。但实际上，Javascript函数上的一个“陷阱”就体现在Javascript两种类型的函数定义上。 JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。 而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用 1234567891011var getName//变量被提升，此时为undefined getName()//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了var getName = function() &#123; console.log('wscat')&#125;//函数表达式此时才开始覆盖函数声明的定义getName()//wscatfunction getName() &#123; console.log('oaoafly')&#125;getName()//wscat 这里就执行了函数表达式的值 所以可以分解为这两个简单的问题来看清楚区别的本质123456var getName;console.log(getName)//undefinedgetName()//Uncaught TypeError: getName is not a functionvar getName = function() &#123; console.log('wscat')&#125; 123456var getName;console.log(getName)//function getName() &#123;console.log('oaoafly')&#125;getName()//oaoaflyfunction getName() &#123; console.log('oaoafly')&#125; 这个区别看似微不足道，但在某些情况下确实是一个难以察觉并且“致命“的陷阱。出现这个陷阱的本质原因体现在这两种类型在函数提升和运行时机（解析时/运行时）上的差异。当然我们给一个总结：Javascript中函数声明和函数表达式是存在区别的，函数声明在JS解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。而函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用。所以第二问的答案就是4，5的函数声明被4的函数表达式覆盖了 第三问Foo().getName(); 先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。Foo函数的第一句getName = function () { alert (1); };是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为function(){alert(1)}。此处实际上是将外层作用域内的getName函数修改了。 注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。 之后Foo函数的返回值是this，而JS的this问题已经有非常多的文章介绍，这里不再多说。简单的讲，this的指向是由所在函数的调用方式决定的。而此处的直接调用方式，this指向window对象。遂Foo函数返回的是window对象，相当于执行window.getName()，而window中的getName已经被修改为alert(1)，所以最终会输出1 此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题我们可以利用下面代码来回顾下这两个知识点 12345678910111213var name = \"Wscats\";//全局变量window.name = \"Wscats\";//全局变量function getName() &#123; name = \"Oaoafly\"; //去掉var变成了全局变量 var privateName = \"Stacsw\"; return function() &#123; console.log(this);//window return privateName &#125;&#125;var getPrivate = getName(\"Hello\"); //当然传参是局部变量，但函数里面我没有接受这个参数console.log(name) //Oaoaflyconsole.log(getPrivate()) //Stacsw 因为JS没有块级作用域，但是函数是能产生一个作用域的，函数内部不同定义值的方法会直接或者间接影响到全局或者局部变量，函数内部的私有变量可以用闭包获取，函数还真的是第一公民呀~而关于this，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象所以第三问中实际上就是window在调用Foo()函数，所以this的指向是window 12window.Foo().getName();//-&gt;window.getName(); 第四问直接调用getName函数，相当于window.getName()，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1，也就是说Foo执行后把全局的getName函数给重写了一次，所以结果就是Foo()执行重写的那个getName函数 第五问第五问new Foo.getName();此处考察的是JS的运算符优先级问题，我觉得这是这题灵魂的所在，也是难度比较大的一题下面是JS运算符的优先级表格，从高到低排列。可参考MDN运算符优先级 new (带参数列表)比new (无参数列表)高比函数调用高，跟成员访问同级 new Foo.getName();的优先级是这样的 相当于是: 1new (Foo.getName)(); 所以这里实际上将getName函数作为了构造函数来执行，遂弹出2。 第六问这一题比上一题的唯一区别就是在Foo那里多出了一个括号，这个有括号跟没括号我们在第五问的时候也看出来优先级是有区别的1(new Foo()).getName() 这里还有一个小知识点，Foo作为构造函数有返回值，所以这里需要说明下JS中的构造函数返回值问题。 构造函数的返回值在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。而在JS中构造函数可以有返回值也可以没有。 没有返回值则按照其他语言一样返回实例化对象。 1234function Foo(name)&#123; this.name = name&#125;console.log(new Foo('wscats')) 若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（String,Number,Boolean,Null,Undefined）则与无返回值相同，实际返回其实例化对象。 12345function Foo(name)&#123; this.name = name return 520&#125;console.log(new Foo('wscats')) 若返回值是引用类型，则实际返回值为这个引用类型。 1234567function Foo(name)&#123; this.name = name return &#123; age:16 &#125;&#125;console.log(new Foo('wscats')) 原题中，由于返回的是this，而this在构造函数中本来就代表当前实例化对象，最终Foo函数返回实例化对象。之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，当前对象的原型对象(prototype)中寻找getName函数。当然这里再拓展个题外话，如果构造函数和原型链都有相同的方法，如下面的代码，那么默认会拿构造函数的公有方法而不是原型链，这个知识点在原题中没有表现出来，后面改进版我已经加上。 123456789101112function Foo(name) &#123; this.name = name this.getName = function() &#123; return this.name &#125;&#125;Foo.prototype.name = 'Oaoafly';Foo.prototype.getName = function() &#123; return 'Oaoafly'&#125;console.log((new Foo('Wscats')).name)//Wscatsconsole.log((new Foo('Wscats')).getName())//Wscats 第七问new new Foo().getName();同样是运算符优先级问题。做到这一题其实我已经觉得答案没那么重要了，关键只是考察面试者是否真的知道面试官在考察我们什么。最终实际执行为: 1new ((new Foo()).getName)(); 先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new，所以最终结果为3 答案1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//答案：Foo.getName();//2getName();//4Foo().getName();//1getName();//1new Foo.getName();//2new Foo().getName();//3new new Foo().getName();//3","tags":[{"name":"js","slug":"js","permalink":"//H_MZ.me/tags/js/"}]},{"title":"vue2.0下拉刷新和上拉加载组件","date":"2017-01-02T15:45:34.000Z","path":"posts/uncategorized/2017-01-02-vue2.0下拉刷新和上拉加载组件.html","text":"最近一直在用vue做项目,闲来无事就整理一下项目中所用到的组件,现在网上基于vue2的下拉刷新的组件并没有什么很好用的,想着就自己写一套吧.刚开始写的配置内容比较少,以后会持续增加. 组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;template&gt; &lt;div class=\"m-pull-refresh view\"&gt; &lt;div :id=\"scrollId\" class=\"wrapper\"&gt; &lt;div class=\"xs-container\" id=\"container\"&gt; &lt;div class=\"xs-content\" id=\"xs-content\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;/** * pullDown &amp; pullUp * @module components/pull-refresh * @desc 下拉刷新和上拉加载组件 * @param bol usePullDown - 是否使用下拉刷新 default: false * @param bol usePullUp - 是否使用上拉加载 default: false * @param obj pulldownConfig - 下拉刷新自定义配置 * @param obj pullupConfig - 上拉加载自定义配置 * @example * &lt;cubee-pull-refresh ref=\"pullRefreshEl\" :usePullDown=\"true\" :usePullUp=\"true\" @on-pulldown=\"pullDownAction\" @on-pullup=\"pullUpAction\"&gt; &lt;div class=\"f-flex f-flexr item\" v-for=\"item in matchList\"&gt; &lt;div class=\"f-flex1 itemc\"&gt;&#123;&#123;item.homeName&#125;&#125;&lt;/div&gt; &lt;div class=\"f-flex1 itemc\"&gt;&#123;&#123;item.awayName&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/cubee-pull-refresh&gt; */import XScroll from 'xscroll/build/cmd/xscroll'import PullDown from 'xscroll/build/cmd/plugins/pulldown'import Pullup from 'xscroll/build/cmd/plugins/pullup'// 下拉刷新默认配置const pulldownDefaultConfig = () =&gt; (&#123; content: '&lt;span style=\"margin-right: 10px;\"&gt;↓&lt;/span&gt;&lt;span&gt;下拉刷新&lt;/span&gt;', height: 70, autoRefresh: false, downContent: '&lt;span style=\"margin-right: 10px;\"&gt;↓&lt;/span&gt;&lt;span&gt;下拉刷新&lt;/span&gt;', upContent: '&lt;span style=\"margin-right: 10px;\"&gt;↑&lt;/span&gt;&lt;span&gt;松开即可刷新&lt;/span&gt;', loadingContent: '&lt;span style=\"width: 30px; height: 30px; display: inline-block; vertical-align: middle; background: url(http://ohy4bt9w4.bkt.clouddn.com/image/icon/icon_refresh.png) no-repeat center; background-size: 100% auto; animation: loading 0.5s infinite linear;\"&gt;&lt;/span&gt;', clsPrefix: 'xs-plugin-pulldown-'&#125;)// 上拉加载默认配置const pullupDefaultConfig = () =&gt; (&#123; content: '&lt;span&gt;&lt;/span&gt;', pullUpHeight: 50, height: 50, autoRefresh: false, downContent: '&lt;span&gt;&lt;/span&gt;', upContent: '&lt;span&gt;&lt;/span&gt;', loadingContent: '&lt;span style=\"width: 30px; height: 30px; display: block; margin: 10px auto; background: url(http://ohy4bt9w4.bkt.clouddn.com/image/icon/icon_refresh.png) no-repeat center; background-size: 100% auto; animation: loading 0.5s infinite linear;\"&gt;&lt;/span&gt;', clsPrefix: 'xs-plugin-pullup-'&#125;)export default &#123; name: 'pull-refresh', data() &#123; return &#123; scrollId: 'scroll', &#125; &#125;, props: &#123; usePullDown: &#123; type: Boolean, default: false &#125;, usePullUp: &#123; type: Boolean, default: false &#125;, pulldownConfig: &#123; type: Object, default () &#123; return &#123;&#125; &#125; &#125;, pullupConfig: &#123; type: Object, default () &#123; return &#123;&#125; &#125; &#125;, &#125;, methods: &#123; // 初始化iscroll _init() &#123; this.xscroll = new XScroll(&#123; renderTo: \"#\" + this.scrollId, lockX: true, scrollbarX: false &#125;); if(this.usePullDown) &#123; let config = Object.assign(pulldownDefaultConfig(), this.pulldownConfig); this.pulldown = new PullDown(config) ; this.xscroll.plug(this.pulldown); this.pulldown.on('loading', (e) =&gt; &#123; this.$emit('on-pulldown') &#125;) &#125; if(this.usePullUp) &#123; let config = Object.assign(pullupDefaultConfig(), this.pullupConfig); this.pullup = new Pullup(config) ; this.xscroll.plug(this.pullup); this.pullup.on('loading', (e) =&gt; &#123; this.$emit('on-pullup') &#125;) &#125; this.xscroll.render(); &#125;, refresh() &#123; // 下拉刷新 this.pulldown.reset(() =&gt; &#123; this.reset() &#125;) &#125;, loadMore() &#123; // 上拉加载 this.pullup.complete(); this.reset(); &#125;, reset() &#123; // 重置滚动条 setTimeout(() =&gt; &#123; this.xscroll &amp;&amp; this.xscroll.render() &#125;) &#125; &#125;, mounted() &#123; this.scrollId = 'scroll' + new Date().getTime(); this.$nextTick(() =&gt; &#123; let wrapper = document.getElementById(this.scrollId); let scroller = document.getElementById(\"container\"); let content = document.getElementById(\"xs-content\"); scroller.style.minHeight = (wrapper.clientHeight + 1) + \"px\"; content.style.minHeight = (wrapper.clientHeight + 1) + \"px\"; // 这里的操作是为了当内容的高度小于wrapper的高度是也显示滚动条 // this._init(); &#125;) &#125;&#125;&lt;/script&gt;&lt;style lang=\"sass\" scoped&gt; .m-pull-refresh &#123; font-size: 14px; .wrapper&#123; position: absolute; width:100%; height: 100%; overflow: scroll; -webkit-overflow-scrolling:touch; .xs-content &#123; height: 100%; &#125; &#125; &#125; @-webkit-keyframes loading &#123; from &#123; -webkit-transform: rotate(0deg) translateZ(0); &#125; to &#123; -webkit-transform: rotate(360deg) translateZ(0); &#125; &#125; @keyframes loading &#123; from &#123; transform: rotate(0deg) translateZ(0); &#125; to &#123; transform: rotate(360deg) translateZ(0); &#125; &#125;&lt;/style&gt;","tags":[{"name":"vue2.0 下拉刷新 上拉加载","slug":"vue2-0-下拉刷新-上拉加载","permalink":"//H_MZ.me/tags/vue2-0-下拉刷新-上拉加载/"}]},{"title":"vue2.0 router 切换动画","date":"2016-12-16T15:45:34.000Z","path":"posts/uncategorized/2016-12-16-vue2.0 router切换动画.html","text":"对于动画vue2.0 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if）条件展示 （使用 v-show）动态组件组件根节点 app.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;template&gt; &lt;div id=\"app\" class=\"g-body\"&gt; &lt;div class=\"g-main\"&gt; &lt;transition :name=\"viewAnimate\"&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters, mapActions&#125; from 'vuex';export default &#123; name: 'app', data() &#123; return &#123; isLoading: false, viewAnimate: '' &#125; &#125;, computed: mapGetters(&#123; direction: 'getDirection' &#125;), watch: &#123; '$route': function(val, oldVal) &#123; console.log('------------监听到路由变化---------',this.direction); if (this.direction === 'forward') &#123; this.viewAnimate = 'slide-in'; &#125; else &#123; this.viewAnimate = 'slide-out'; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"sass\"&gt; html, body &#123; height: 100%; &#125; .g-body &#123; height: 100%; position: relative; overflow: hidden; .g-main &#123; height: 100%; .view &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; width: 100%; background: #fff; &#125; &#125; &#125; /** * vue-router transition */ .slide-in-enter-active &#123; z-index: 2; visibility: visible; -webkit-animation-duration: 0.4s; animation-duration: 0.4s; -webkit-animation-name: slide-in-enter; animation-name: slide-in-enter; &#125; .slide-in-leave-active &#123; z-index: 1; visibility: visible; -webkit-animation-duration: 0.4s; animation-duration: 0.4s; -webkit-animation-name: slide-in-leave; animation-name: slide-in-leave; &#125; .slide-out-enter-active &#123; z-index: 1; -webkit-animation-duration: 0.4s; animation-duration: 0.4s; -webkit-animation-name: slide-out-enter; animation-name: slide-out-enter; &#125; .slide-out-leave-active &#123; z-index: 2; -webkit-animation-duration: 0.4s; animation-duration: 0.4s; -webkit-animation-name: slide-out-leave; animation-name: slide-out-leave; &#125; .slide-in-enter &#123; visibility: hidden; -webkit-transform: translate3d(100%, 0, 0); transform: translate3d(100%, 0, 0); &#125; .slide-out-enter &#123; visibility: hidden; -webkit-transform: translate3d(-100%, 0, 0); transform: translate3d(-100%, 0, 0); &#125; @-webkit-keyframes slide-in-enter &#123; from &#123; -webkit-transform: translate3d(100%, 0, 0); transform: translate3d(100%, 0, 0); &#125; to &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; &#125; @keyframes slide-in-enter &#123; from &#123; -webkit-transform: translate3d(100%, 0, 0); transform: translate3d(100%, 0, 0); &#125; to &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; &#125; @-webkit-keyframes slide-in-leave &#123; from &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; to &#123; -webkit-transform: translate3d(-33%, 0, 0); transform: translate3d(-33%, 0, 0); &#125; &#125; @keyframes slide-in-leave &#123; from &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; to &#123; -webkit-transform: translate3d(-33%, 0, 0); transform: translate3d(-33%, 0, 0); &#125; &#125; @-webkit-keyframes slide-out-enter &#123; from &#123; -webkit-transform: translate3d(-33%, 0, 0); transform: translate3d(-33%, 0, 0); &#125; to &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; &#125; @keyframes slide-out-enter &#123; from &#123; -webkit-transform: translate3d(-33%, 0, 0); transform: translate3d(-33%, 0, 0); &#125; to &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; &#125; @-webkit-keyframes slide-out-leave &#123; from &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; to &#123; -webkit-transform: translate3d(100%, 0, 0); transform: translate3d(100%, 0, 0); &#125; &#125; @keyframes slide-out-leave &#123; from &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; to &#123; -webkit-transform: translate3d(100%, 0, 0); transform: translate3d(100%, 0, 0); &#125; &#125;&lt;/style&gt; indexRouter.js12345678910111213/*** * 全局钩子函数 ***/// 视图切换动画逻辑const commit = IndexStore.commit || IndexStore.dispatch;router.afterEach(route =&gt; &#123; setTimeout(function() &#123; var direction = 'forward'; commit('SET_DIRECTION', &#123; direction &#125;); &#125;, 50)&#125;)","tags":[{"name":"vue2.0 router 动画","slug":"vue2-0-router-动画","permalink":"//H_MZ.me/tags/vue2-0-router-动画/"}]}]